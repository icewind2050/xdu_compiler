# 编译原理

## 词法分析

### 词法分析器

#### 功能

1. 识别出源程序中的各个单词符号,并将其转换为内部编码形式.
2. 删除无用的空白符,回车符以及无用的非实质性字符.
3. 删除注释
4. 进行语法检查

#### 工作方式

1. 词法分析器作为编译器独立执行任务
2. 词法分析器作为语法分析器的子程序执行任务
3. 词法分析器和语法分析器并行工作

### 形式化描述

#### 语言

**定义**:**有限**字母表上$\Sigma$上**有限**长度的字符串的集合

##### 常用名词

> **前缀**:移走字符串尾部的任意个符号后余下的部分
> **后缀**:移走字符串头部的任意个符号后余下的部分
> **子串**:移走前缀和后缀的字符串余下的部分
> **子序列**:从字符串中的任意个位置删除任意个符号后余下的部分
> **逆转**:将字符串中的符号按相反次序写出的字符串
> **连接**:x和y是字符串,连接xy是将y的符号接在x的符号之后
> **幂**:一个字符串和自身的n-1次连接

##### 运算

$L$和$M$都是一个字符串集合

1. **合并**:$$L\cup M=\{s\mid s\in L\vee s\in M\}$$
2. **连接**:$$LM=\{st\mid s\in L\wedge t\in M\}$$
3. **幂**:$$L^0=\{\epsilon\},L^1=L,L^2=LL,L^n=L^{n-1}L$$
4. **Kleene闭包**:$$L^*=\overset{\infin}{\cup}L^i=L^0\cup L^1\cup \cdots\quad i\geq 0$$
5. **正闭包**:$$L^+=\overset{\infin}{\cup}L^i=L^1\cup L^2\cup\cdots\quad i\geq 1$$

#### 正规式和正规集

**常用名词**:
> 1.L(r)表示由字母表r构成的语言
> 2.正规集表示用正规式描述的语言

##### 定义字母表$\Sigma$上的正规式

1. $\epsilon,\emptyset$是$\Sigma$上的正规式,表示的正规集为$\{\epsilon\},\emptyset$
2. $\forall a\in \Sigma$,$a$是$\Sigma$上的正规式,表示的正规集为$\{a\}$
3. 假定$e_1,e_2$为$\Sigma$上的正规式,表示的正规集为$L(e_1),L(e_2)$则
   1. $(e_1\mid e_2)$为正规式,表示的正规集为$L(e_1)\cup L(e_2)$
   2. $(e_1\cdot e_2)$为正规式,表示的正规集为$L(e_1)L(e_2)$
   3. $(e_1)^*$为正规式,表示的正规集为$(L(e_1))^*$
有限使用以上三个步骤定义的表达式称为$\Sigma$上的正规式

> 运算顺序
> 闭包运算优先级最高,左结合
> 连接运算优先级第二,左结合
> 或运算优先级最低,左结合

##### 运算性质

常用运算性质:
> $A|B = B|A$
>
> $A|(B|C)=(A|B)|C$
>
> $A(BC)=(AB)C$
>
> $A(B|C)=AB|AC\qquad(A|B)C=AC|BC$
>
> $\epsilon A=A\quad A\epsilon = A$
>
> $A^*=(A|\epsilon)^*$
>
> $A^{**}=A^*$

##### 简化正规式

1. 正闭包:$r$为表示$L(r)$正规式,$r^+$为表示$(L(r))^+$的正规式且$$r^+=rr^*=r^*r,r^*=r^+\mid\epsilon$$
2. 可缺省:$r$为表示$L(r)$正规式,$r?$为表示$L(r)\cup\{\epsilon\}$的正规式
3. 字符组:
   1. 枚举方式:$$[abc]=a|b|c$$
   2. 分段方式:$$[0-9]=[0123456789]$$
4. 非字符组:若$[r]$是一个正规式,则$[^r]$表示$\Sigma-L(r)$

### 有限状态自动机

#### 状态转换图

由一组矢量线连接的有限个节点组成的有向图,每个节点均代表识别单词时语法分析器所处的状态

**例如**:从状态一输入x则读入x到状态2,输入y则读入y到状态3

```mermaid
graph LR
D1((1))
D2((2))
D3((3))

D1-- x -->D2
D1-- y -->D3
```

**例如**:可以识别一定的字符串

```mermaid
graph LR
D0((0))
D1((1))
D2((2))

D0-- 字母 -->D1
D1-- 字母或其他数字 -->D1
D1-- 其他字符 -->D2
```

#### 非确定型有限状态自动机(NFA)

##### 定义

NFA是一个五元组:$$M=(S,\Sigma,move,s_0,F)$$

> $S$:一个有限的状态集合
> $\Sigma$:一个输入符号的集合
> $move$:$S\times\Sigma\rarr S$是一个状态转移函数,$move(s_i,ch)=s_j$表示$s_i$状态遇到输入字符$ch$转移到$s_j$状态
> $s_0$为初始状态
> $F$为终态集合,$F\subseteq S$

#### 确定型有限自动机

##### DFA定义

1. DFA是NFA的一种
2. 任何状态没有$\epsilon$转换
3. 对任何状态$s_j$和任意输入符号$a$,最多只有一条标记着$a$的便离开$s_j$.

### 正规式到词法分析器

#### 由正规式构造等价的NFA(Thompson算法)

步骤:

1. 对于$\epsilon$构造NFA如下

    ```mermaid
    graph LR
    D0((s0))
    D1((f))

    D0-- ε --> D1
    ```

2. 对于$\Sigma$中的每个符号$a$构造NFA

    ```mermaid
    graph LR
    D0((s0))
    D1((f))

    D0-- a --> D1
    ```

3. 如果$M(p)$和$M(q)$分别是正规式$p$和$q$的NFA则
   1. 对于正规式$p|q$构造合成NFA:$M(p|q)$结果如下:

        ```mermaid
        graph LR
        D0((s0))
        D1((Sp))
        D2((Sq))
        D3((Fp))
        D4((Fq))
        D5((f))

        subgraph "M(q)"
            D1-->D3
        end
        subgraph "M(p)"
            D2-->D4
        end
        D0-- ε -->D1
        D0-- ε -->D2
        D3-- ε -->D5
        D4-- ε -->D5
        ```

   2. 对于正规式$pq$构造合成NFA:$M(pq)$结果如下:

        ```mermaid
        graph LR
        D0((s0))
        D1((sf))
        D2((f))
        D3((sf))
        subgraph "M(p)"
            D0-->D1
        end
        subgraph "M(q)"
            D1-- ε -->D3
            D3-->D2
        end
        ```

   3. 对于正规式$p^*$构造如下

        ```mermaid
        graph TD
        D0((s0))
        D1((Sp))
        D2((Fp))
        D3((f))
        subgraph "M(p)" 
            D2-- ε -->D1
        end
        D0-- ε -->D1
        D2-- ε -->D3
        ```

4. 对于括起来的正规式$(p)$用$M(p)$本身作为它的NFA

#### NFA到DFA

> 名词定义:
> 1.$\epsilon$_CLOSURE($I$):
> 如果$q\in I$,则$q\in \epsilon \_CLOSURE(I)$
> 如果$q\in I$,则$q'$为经过任意条$\epsilon$边可以到达的状态，这些状态都属于$\epsilon$_CLOSURE($I$）
> $I$是状态集的一个子集,$a\in \Sigma$,定义$I_a = \epsilon \_CLOUSURE(J)$,其中J是从I中的任意一个状态节点出发经过一条$a$边和任意条$\epsilon$边能到达的状态的全体

##### NFA到DFA的确定化方法

构造一张表格,该表格有n列,n为字母表的个数,可以将每一列命名为$I_x$,x为字母表中的字母.

1. 首先置第一行第一列为$\epsilon$_CLOSURE($X$),X为初态,该项为初态的闭包.
2. 根据上述的定义依次在后面的每一行填入相应$I_x$
3. 检查填入的$I_x$,如果它没有在第一列出现过,将其填入到第一列的末尾空项中,如果出现过则略过这一项
4. 对未填入$I_x$的每一行重复该过程,直到表所有产生的$I_x$在第一列都出现过为止.
5. 将表中的每一项赋予一个新的状态名
6. 根据新的状态转移表画DFA

例如:
NFA如下:

```mermaid
    graph LR
    D0((0))
    D1((1))
    D2((2))
    D3((3))
    D4((4))
    D5((5))
    D6((6))
    D7((7))
    D8((8))
    D9((9))
    D10((10))
    
    D0-- ε -->D1
    D0-- ε -->D7
    D1-- ε -->D2
    D1-- ε -->D4
    D2-- a -->D3
    D4-- b -->D5
    D3-- ε -->D6
    D5-- ε -->D6
    D6-- ε -->D1
    D6-- ε -->D7
    D7-- a -->D8
    D8-- b -->D9
    D9-- b -->D10
```

由于字母表中有两个元素a,b所以状态转化矩阵共有三列,如下所示:

|$I$|$I_a$|$I_b$|
|:---:|:---:|:---:|
|$\{0,1,2,4,7\}$|$\{3,8,6,7,1,2,4\}$|$\{5,6,7,1,2,4\}$|
|$\{3,8,6,7,1,2,4\}$|$\{8,3,6,7,1,2,4\}$|$\{9,5,6,7,1,2,4\}$|
|$\{5,6,7,1,2,4\}$|$\{8,3,6,7,1,2,4\}$|$\{5,6,7,1,2,4\}$|
|$\{9,5,6,7,1,2,4\}$|$\{8,3,6,7,1,2,4\}$|$\{10,5,6,7,1,2,4\}$|
|$\{10,5,6,7,1,2,4\}$|$\{8,3,6,7,1,2,4\}$|$\{5,6,7,1,2,4\}$|

将其重命名可以得到如下矩阵
其
|S|a|b|
|:---:|:---:|:---:|
|A|B|C|
|B|B|D|
|C|B|C|
|D|B|E|
|E|B|C|

生成的DFA如下

```mermaid
    graph LR
    D0((A))
    D1((B))
    D2((C))
    D3((D))
    D4((E))

    D0-- a -->D1
    D0-- b -->D2
    D1-- a -->D1
    D1-- a -->D3
    D1-- b -->D3
    D2-- b -->D2
    D2-- a -->D1
    D3-- b -->D4
    D4-- a -->D1
    D4-- b -->D2
```

##### 状态转移表的化简

如果对于任意的输入x,p和q转移后的状态相同,认为p和q等价,可以将等价的状态合一.

## 语法分析

### 上下文无关文法CFG

#### CFG的定义

> 一个CFG为一个四元组G=(N,T,P,S)
> N为一个非空有限集合,元素为非终结符,非终结符定义了终结符串的集合
> T为一个非空有限集合,元素为终结符,$T\cap N=\emptyset$
> P为产生式的集合,产生式为$A\rarr a$,$A\in N,a\in(T\cup N)^*$,指出了终结符和非终结符组成串的形式
> S为开始符号

#### 语法分析的术语

##### 推导

利用产生式生成句子的过程,使用产生式$A\rarr \gamma$的右部代替文法符号序列$\alpha A\beta$中的A得到$\alpha\gamma\beta$的过程称为$\alpha A\beta$直接推导出$\alpha\gamma\beta$记作$\alpha A\beta\rArr\alpha\gamma\beta$

可以使用符号$\overset{*}{\rArr}$来表示多步推导,即对一个表达式多次使用相同或不同的产生式得到的句子.

推导具有传递性,自反性

##### 上下文无关语言$L(G)$

由CFG G所产生的语言$L(G)$被定义为$$L(G)=\{\omega\mid S\overset{*}{\rArr}\omega \quad and \quad \omega\in T^*\}$$

##### 最左推导和左句型

在推导过程中,每次都替换掉句型中最左边的非终结符,这样的推导称为最左推导,由最左推导产生的句型称为左句型

#### 语法树和二义性

##### 语法树

定义: 设$G=(N,T,P,S)$是一个文法,满足以下条件

1. 每一个节点有一个标记$X$,$X\in N\cup T$
2. 每一个节点由根可达
3. 如果节点有后继,则$X\in N$
4. 若$A$有$k$个后继,从左到右为$X_1,X_2,\cdots,X_k$,则$A\rarr X_1X_2\cdots X_k\in P$

类似于把一个由非终结符构成的句子进行展开,把非终结符不断的依次展开,最后的所有叶子都是终结符.

### 自上而下的语法分析

从语法开始符号出发,为已给定的字符串构造一个最左推导

#### 文法的左递归

如果文法中出现这样的产生式$A\rarr A\alpha$,称该产生式对A直接左递归,显然不能用自上而下的语法分析

##### 消除文法的左递归

假设有这样的文法$A\rarr A\alpha\mid \beta$,且$\beta$不以$A$为开头,改写为$$A\rarr \beta A'$$$$A'\rarr \alpha A'\mid \epsilon$$

例如:$$S\rarr Aa\mid b$$$$A\rarr Sc\mid\epsilon$$没有直接左递归,但是用$S\rarr Aa\mid b$代入$A\rarr Sc\mid\epsilon$就出现了直接左递归$A\rarr Aac\mid bc\mid\epsilon$消去左递归得到$$S\rarr Aa\mid b$$$$A\rarr bcA'\mid A'$$$$A'\rarr acA'\mid\epsilon$$

#### 递归下降分析法

例如:给出文法$G[S]$为$$\begin{align*}
S&\rarr E+S\mid\epsilon\\
E&\rarr E+S\mid E-T\mid T\\
T&\rarr T*F\mid T/F\mid T \quad mod\quad F \mid F
F&\rarr (E)\mid i\mid num
\end{align*}$$
消去左递归和左因子得到了递归下降分析所需的文法$$\begin{align*}
    S&\rarr E+S\mid\epsilon\\
    E&\rarr TE'\\
    E'&\rarr +TE'\mid -TE'\mid \epsilon\\
    T&\rarr FT'\\
    T'&\rarr *FT'\mid /FT'\mid mod\quad FT'\mid\epsilon\\
    F&\rarr (E)\mid i\mid num\\
\end{align*}$$构造状态转换图构造方法如下

1. 为非终结符$A$建立一个初态和一个终态
2. 为$A\rarr X_1X_2\cdots X_n$构造从初态到终态的路径,边标记为$X_n$
3. 根据识别同一集合的方式,化简状态转换图

化简规则:

1. 标记为A的边可等价为标记$\epsilon$的边转向A状态转换图的初态
2. 标记为$\epsilon$的边所连接的两个状态可以合并
3. 标记相同的路径可以合并
4. 等价的状态可以合并

##### 文法的EBNF表示规则

> <>:尖括号内为语法构造成分,为非终结符
> ::= 表示该符号的左部由右部定义
> | 表示或的关系
> {} 表示其内的语法成分可以重复,可以加上重复的上下界
> [] 表示其中的成分为任选项

化简所得的语法为:$$\begin{align*}
    S&\rarr\{E+\}\\
    E&\rarr T\{(+|-)T\}\\
    T&\rarr F\{(*|/|mod)F\}\\
    F&\rarr (E)|i|nuum\\
\end{align*}$$

#### 预测分析法

##### FIRST集合和FOLLOW集合

FIRST:
文法符号序列$\alpha$的FIRST定义如下:$$FIRST(\alpha)=\{a|\alpha\overset{*}{\rArr}a\cdots,a\in T\}$$如果$\alpha\overset{*}{\rArr}\epsilon$有$\epsilon\in FIRST(\alpha)$

FOLLOW:
非终结符A的FOLLOW集合定义如下:$$FOLLOW(A)=\{a|S\overset{*}{\rArr}\cdots Aa\cdots,a\in T\}$$若A是某句型的最右符号,则$#\in FOLLOW(A)$

###### FIRST集合的计算

设符号为X有

1. 若$X\in T$,则$FIRST(X)=\{X\}$
2. 若$X\in N$,且$X\rarr a/cdots \in P,a\in T$,则令$a\in FIRST(X)$,若$X\rarr\epsilon\in P$,则令$\epsilon\in FIRST(X)$
3. 若