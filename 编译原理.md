# 编译原理

## 词法分析

### 词法分析器

#### 功能

1. 识别出源程序中的各个单词符号,并将其转换为内部编码形式.
2. 删除无用的空白符,回车符以及无用的非实质性字符.
3. 删除注释
4. 进行语法检查

#### 工作方式

1. 词法分析器作为编译器独立执行任务
2. 词法分析器作为语法分析器的子程序执行任务
3. 词法分析器和语法分析器并行工作

### 形式化描述

#### 语言

**定义**:**有限**字母表上$\Sigma$上**有限**长度的字符串的集合

##### 常用名词

> **前缀**:移走字符串尾部的任意个符号后余下的部分
> **后缀**:移走字符串头部的任意个符号后余下的部分
> **子串**:移走前缀和后缀的字符串余下的部分
> **子序列**:从字符串中的任意个位置删除任意个符号后余下的部分
> **逆转**:将字符串中的符号按相反次序写出的字符串
> **连接**:x和y是字符串,连接xy是将y的符号接在x的符号之后
> **幂**:一个字符串和自身的n-1次连接

##### 运算

$L$和$M$都是一个字符串集合

1. **合并**:$$L\cup M=\{s\mid s\in L\vee s\in M\}$$
2. **连接**:$$LM=\{st\mid s\in L\wedge t\in M\}$$
3. **幂**:$$L^0=\{\epsilon\},L^1=L,L^2=LL,L^n=L^{n-1}L$$
4. **Kleene闭包**:$$L^*=\overset{\infin}{\cup}L^i=L^0\cup L^1\cup \cdots\quad i\geq 0$$
5. **正闭包**:$$L^+=\overset{\infin}{\cup}L^i=L^1\cup L^2\cup\cdots\quad i\geq 1$$

#### 正规式和正规集

**常用名词**:
> 1.L(r)表示由字母表r构成的语言
> 2.正规集表示用正规式描述的语言

##### 定义字母表$\Sigma$上的正规式

1. $\epsilon,\emptyset$是$\Sigma$上的正规式,表示的正规集为$\{\epsilon\},\emptyset$
2. $\forall a\in \Sigma$,$a$是$\Sigma$上的正规式,表示的正规集为$\{a\}$
3. 假定$e_1,e_2$为$\Sigma$上的正规式,表示的正规集为$L(e_1),L(e_2)$则
   1. $(e_1\mid e_2)$为正规式,表示的正规集为$L(e_1)\cup L(e_2)$
   2. $(e_1\cdot e_2)$为正规式,表示的正规集为$L(e_1)L(e_2)$
   3. $(e_1)^*$为正规式,表示的正规集为$(L(e_1))^*$
有限使用以上三个步骤定义的表达式称为$\Sigma$上的正规式

> 运算顺序
> 闭包运算优先级最高,左结合
> 连接运算优先级第二,左结合
> 或运算优先级最低,左结合

##### 运算性质

常用运算性质:
> $A|B = B|A$
>
> $A|(B|C)=(A|B)|C$
>
> $A(BC)=(AB)C$
>
> $A(B|C)=AB|AC\qquad(A|B)C=AC|BC$
>
> $\epsilon A=A\quad A\epsilon = A$
>
> $A^*=(A|\epsilon)^*$
>
> $A^{**}=A^*$

##### 简化正规式

1. 正闭包:$r$为表示$L(r)$正规式,$r^+$为表示$(L(r))^+$的正规式且$$r^+=rr^*=r^*r,r^*=r^+\mid\epsilon$$
2. 可缺省:$r$为表示$L(r)$正规式,$r?$为表示$L(r)\cup\{\epsilon\}$的正规式
3. 字符组:
   1. 枚举方式:$$[abc]=a|b|c$$
   2. 分段方式:$$[0-9]=[0123456789]$$
4. 非字符组:若$[r]$是一个正规式,则$[^r]$表示$\Sigma-L(r)$

### 有限状态自动机

#### 状态转换图

由一组矢量线连接的有限个节点组成的有向图,每个节点均代表识别单词时语法分析器所处的状态

**例如**:从状态一输入x则读入x到状态2,输入y则读入y到状态3

```mermaid
graph LR
D1((1))
D2((2))
D3((3))

D1-- x -->D2
D1-- y -->D3
```

**例如**:可以识别一定的字符串

```mermaid
graph LR
D0((0))
D1((1))
D2((2))

D0-- 字母 -->D1
D1-- 字母或其他数字 -->D1
D1-- 其他字符 -->D2
```

#### 非确定型有限状态自动机(NFA)

##### 定义

NFA是一个五元组:$$M=(S,\Sigma,move,s_0,F)$$

> $S$:一个有限的状态集合
> $\Sigma$:一个输入符号的集合
> $move$:$S\times\Sigma\rarr S$是一个状态转移函数,$move(s_i,ch)=s_j$表示$s_i$状态遇到输入字符$ch$转移到$s_j$状态
> $s_0$为初始状态
> $F$为终态集合,$F\subseteq S$

#### 确定型有限自动机

##### DFA定义

1. DFA是NFA的一种
2. 任何状态没有$\epsilon$转换
3. 对任何状态$s_j$和任意输入符号$a$,最多只有一条标记着$a$的便离开$s_j$.

### 正规式到词法分析器

#### 由正规式构造等价的NFA(Thompson算法)

步骤:

1. 对于$\epsilon$构造NFA如下

    ```mermaid
    graph LR
    D0((s0))
    D1((f))

    D0-- ε --> D1
    ```

2. 对于$\Sigma$中的每个符号$a$构造NFA

    ```mermaid
    graph LR
    D0((s0))
    D1((f))

    D0-- a --> D1
    ```

3. 如果$M(p)$和$M(q)$分别是正规式$p$和$q$的NFA则
   1. 对于正规式$p|q$构造合成NFA:$M(p|q)$结果如下:

        ```mermaid
        graph LR
        D0((s0))
        D1((Sp))
        D2((Sq))
        D3((Fp))
        D4((Fq))
        D5((f))

        subgraph "M(q)"
            D1-->D3
        end
        subgraph "M(p)"
            D2-->D4
        end
        D0-- ε -->D1
        D0-- ε -->D2
        D3-- ε -->D5
        D4-- ε -->D5
        ```

   2. 对于正规式$pq$构造合成NFA:$M(pq)$结果如下:

        ```mermaid
        graph LR
        D0((s0))
        D1((sf))
        D2((f))
        D3((sf))
        subgraph "M(p)"
            D0-->D1
        end
        subgraph "M(q)"
            D1-- ε -->D3
            D3-->D2
        end
        ```

   3. 对于正规式$p^*$构造如下

        ```mermaid
        graph TD
        D0((s0))
        D1((Sp))
        D2((Fp))
        D3((f))
        subgraph "M(p)" 
            D2-- ε -->D1
        end
        D0-- ε -->D1
        D2-- ε -->D3
        ```

4. 对于括起来的正规式$(p)$用$M(p)$本身作为它的NFA

#### NFA到DFA

> 名词定义:
> 1.$\epsilon$_CLOSURE($I$):
> 如果$q\in I$,则$q\in \epsilon \_CLOSURE(I)$
> 如果$q\in I$,则$q'$为经过任意条$\epsilon$边可以到达的状态，这些状态都属于$\epsilon$_CLOSURE($I$）
> $I$是状态集的一个子集,$a\in \Sigma$,定义$I_a = \epsilon \_CLOUSURE(J)$,其中J是从I中的任意一个状态节点出发经过一条$a$边和任意条$\epsilon$边能到达的状态的全体

##### NFA到DFA的确定化方法

构造一张表格,该表格有n列,n为字母表的个数,可以将每一列命名为$I_x$,x为字母表中的字母.

1. 首先置第一行第一列为$\epsilon$_CLOSURE($X$),X为初态,该项为初态的闭包.
2. 根据上述的定义依次在后面的每一行填入相应$I_x$
3. 检查填入的$I_x$,如果它没有在第一列出现过,将其填入到第一列的末尾空项中,如果出现过则略过这一项
4. 对未填入$I_x$的每一行重复该过程,直到表所有产生的$I_x$在第一列都出现过为止.
5. 将表中的每一项赋予一个新的状态名
6. 根据新的状态转移表画DFA

例如:
NFA如下:

```mermaid
    graph LR
    D0((0))
    D1((1))
    D2((2))
    D3((3))
    D4((4))
    D5((5))
    D6((6))
    D7((7))
    D8((8))
    D9((9))
    D10((10))
    
    D0-- ε -->D1
    D0-- ε -->D7
    D1-- ε -->D2
    D1-- ε -->D4
    D2-- a -->D3
    D4-- b -->D5
    D3-- ε -->D6
    D5-- ε -->D6
    D6-- ε -->D1
    D6-- ε -->D7
    D7-- a -->D8
    D8-- b -->D9
    D9-- b -->D10
```

由于字母表中有两个元素a,b所以状态转化矩阵共有三列,如下所示:

|$I$|$I_a$|$I_b$|
|:---:|:---:|:---:|
|$\{0,1,2,4,7\}$|$\{3,8,6,7,1,2,4\}$|$\{5,6,7,1,2,4\}$|
|$\{3,8,6,7,1,2,4\}$|$\{8,3,6,7,1,2,4\}$|$\{9,5,6,7,1,2,4\}$|
|$\{5,6,7,1,2,4\}$|$\{8,3,6,7,1,2,4\}$|$\{5,6,7,1,2,4\}$|
|$\{9,5,6,7,1,2,4\}$|$\{8,3,6,7,1,2,4\}$|$\{10,5,6,7,1,2,4\}$|
|$\{10,5,6,7,1,2,4\}$|$\{8,3,6,7,1,2,4\}$|$\{5,6,7,1,2,4\}$|

将其重命名可以得到如下矩阵
其
|S|a|b|
|:---:|:---:|:---:|
|A|B|C|
|B|B|D|
|C|B|C|
|D|B|E|
|E|B|C|

生成的DFA如下

```mermaid
    graph LR
    D0((A))
    D1((B))
    D2((C))
    D3((D))
    D4((E))

    D0-- a -->D1
    D0-- b -->D2
    D1-- a -->D1
    D1-- a -->D3
    D1-- b -->D3
    D2-- b -->D2
    D2-- a -->D1
    D3-- b -->D4
    D4-- a -->D1
    D4-- b -->D2
```

##### 状态转移表的化简

如果对于任意的输入x,p和q转移后的状态相同,认为p和q等价,可以将等价的状态合一.

## 语法分析

### 上下文无关文法CFG

#### CFG的定义

> 一个CFG为一个四元组G=(N,T,P,S)
> N为一个非空有限集合,元素为非终结符,非终结符定义了终结符串的集合
> T为一个非空有限集合,元素为终结符,$T\cap N=\emptyset$
> P为产生式的集合,产生式为$A\rarr a$,$A\in N,a\in(T\cup N)^*$,指出了终结符和非终结符组成串的形式
> S为开始符号

#### 语法分析的术语

##### 推导

利用产生式生成句子的过程,使用产生式$A\rarr \gamma$的右部代替文法符号序列$\alpha A\beta$中的A得到$\alpha\gamma\beta$的过程称为$\alpha A\beta$直接推导出$\alpha\gamma\beta$记作$\alpha A\beta\rArr\alpha\gamma\beta$

<<<<<<< HEAD
可以使用符号$\overset{*}{\rArr}$来表示多步推导,即对一个表达式多次使用相同或不同的产生式得到的句子.

推导具有传递性,自反性

##### 上下文无关语言$L(G)$

由CFG G所产生的语言$L(G)$被定义为$$L(G)=\{\omega\mid S\overset{*}{\rArr}\omega \quad and \quad \omega\in T^*\}$$

##### 最左推导和左句型

在推导过程中,每次都替换掉句型中最左边的非终结符,这样的推导称为最左推导,由最左推导产生的句型称为左句型

#### 语法树和二义性

##### 语法树

定义: 设$G=(N,T,P,S)$是一个文法,满足以下条件

1. 每一个节点有一个标记$X$,$X\in N\cup T$
2. 每一个节点由根可达
3. 如果节点有后继,则$X\in N$
4. 若$A$有$k$个后继,从左到右为$X_1,X_2,\cdots,X_k$,则$A\rarr X_1X_2\cdots X_k\in P$

类似于把一个由非终结符构成的句子进行展开,把非终结符不断的依次展开,最后的所有叶子都是终结符.

### 自上而下的语法分析

从语法开始符号出发,为已给定的字符串构造一个最左推导

#### 文法的左递归

如果文法中出现这样的产生式$A\rarr A\alpha$,称该产生式对A直接左递归,显然不能用自上而下的语法分析

##### 消除文法的左递归

假设有这样的文法$A\rarr A\alpha\mid \beta$,且$\beta$不以$A$为开头,改写为$$A\rarr \beta A'$$$$A'\rarr \alpha A'\mid \epsilon$$

例如:$$S\rarr Aa\mid b$$$$A\rarr Sc\mid\epsilon$$没有直接左递归,但是用$S\rarr Aa\mid b$代入$A\rarr Sc\mid\epsilon$就出现了直接左递归$A\rarr Aac\mid bc\mid\epsilon$消去左递归得到$$S\rarr Aa\mid b$$$$A\rarr bcA'\mid A'$$$$A'\rarr acA'\mid\epsilon$$

#### 递归下降分析法

例如:给出文法$G[S]$为$$\begin{align*}
S&\rarr E+S\mid\epsilon\\
E&\rarr E+S\mid E-T\mid T\\
T&\rarr T*F\mid T/F\mid T \quad mod\quad F \mid F
F&\rarr (E)\mid i\mid num
\end{align*}$$
消去左递归和左因子得到了递归下降分析所需的文法$$\begin{align*}
    S&\rarr E+S\mid\epsilon\\
    E&\rarr TE'\\
    E'&\rarr +TE'\mid -TE'\mid \epsilon\\
    T&\rarr FT'\\
    T'&\rarr *FT'\mid /FT'\mid mod\quad FT'\mid\epsilon\\
    F&\rarr (E)\mid i\mid num\\
\end{align*}$$构造状态转换图构造方法如下

1. 为非终结符$A$建立一个初态和一个终态
2. 为$A\rarr X_1X_2\cdots X_n$构造从初态到终态的路径,边标记为$X_n$
3. 根据识别同一集合的方式,化简状态转换图

化简规则:

1. 标记为A的边可等价为标记$\epsilon$的边转向A状态转换图的初态
2. 标记为$\epsilon$的边所连接的两个状态可以合并
3. 标记相同的路径可以合并
4. 等价的状态可以合并

##### 文法的EBNF表示规则

> <>:尖括号内为语法构造成分,为非终结符
> ::= 表示该符号的左部由右部定义
> | 表示或的关系
> {} 表示其内的语法成分可以重复,可以加上重复的上下界
> [] 表示其中的成分为任选项

化简所得的语法为:$$\begin{align*}
    S&\rarr\{E+\}\\
    E&\rarr T\{(+|-)T\}\\
    T&\rarr F\{(*|/|mod)F\}\\
    F&\rarr (E)|i|nuum\\
\end{align*}$$

#### 预测分析法

##### FIRST集合和FOLLOW集合

FIRST:
文法符号序列$\alpha$的FIRST定义如下:$$FIRST(\alpha)=\{a|\alpha\overset{*}{\rArr}a\cdots,a\in T\}$$如果$\alpha\overset{*}{\rArr}\epsilon$有$\epsilon\in FIRST(\alpha)$

FOLLOW:
非终结符A的FOLLOW集合定义如下:$$FOLLOW(A)=\{a|S\overset{*}{\rArr}\cdots Aa\cdots,a\in T\}$$若A是某句型的最右符号,则$\#\in FOLLOW(A)$

###### FIRST集合的计算

设符号为X文法中的一个符号

1. 若$X\in T$,则$FIRST(X)=\{X\}$
2. 若$X\in N$,且$X\rarr a\alpha \in P,a\in T$,则令$a\in FIRST(X)$,若$X\rarr\epsilon\in P$,则令$\epsilon\in FIRST(X)$
3. 若$X\rarr Y_1Y_2\cdots Y_k\in P$,且$Y_1\in N$,则令令$FIRST(Y_1)-\{\epsilon\}\subseteq FIRST(X)$,对接下来的$Y_2Y_3\cdots Y_k$,如果一个$Y_i$之前的所有项都有$Y\overset{*}{\rArr}\epsilon$,就把$FIRST(Y_i)-\{\epsilon\}\in FIRST(X)$,如果存在$\epsilon\in Y$,把$\epsilon\subseteq FIRST(X)$

###### FOLLOW集合的计算

1. 对于文法的开始符号S,令$\# \in FOLLOW(S)$
2. 对于每一个产生式$A\rarr \alpha B \beta \in P$,令$FIRST(\beta)-\{\epsilon\}\subseteq FOLLOW(B)$
3. 对于每个产生式$A\rarr \alpha B\in P$或$A\rarr \alpha B \beta$,且$\epsilon\in FIRST(\beta)$,则令$FOLLOW(A)\subseteq FOLLOW(B)$

###### 构造预测分析表

1. 对于每一个产生式$A\rarr \alpha$执行以下步骤
2. $\forall a \in FIRST(A)$,把$A\rarr \alpha$加入到$M[A,a]$中
3. 如果$\epsilon\in FIRST(A)$,对$FOLLOW(A)$的每个终结符$b$,把$A\rarr\epsilon$加入到$M[A,b]$

### 自下而上的语法分析

#### 自下而上的语法分析的名词定义

##### 句柄

假设$\alpha\beta\delta$为文法$G$的一个句型(符合文法的句子),如果存在这样一个推导$S\overset{*}{\rArr}\alpha A\delta$,且$A\overset{+}{\rArr}\beta$,则称$\beta$为句型$\alpha\beta\delta$相对于$A$的短语;若$A\rarr\beta$,则称$\beta$为句型$\alpha\beta\delta$相对于$A\rarr\beta$的直接短语

一个句型的最左直接短语称为句柄,短语,直接短语,和句柄可以通过画语法树得到.

语法树中,短语为以任意一个非终结符为根的树,将其的叶子节点从左到右排起来.

直接短语为以非终结符为根,所有子结点全部为叶子节点的树,把子结点从左到右排起来

句柄为最左边的直接短语

#### LR分析法

##### LR(0)分析表的构造

文法:$$\begin{align*}
    &S'\rarr E\\
    &E\rarr aA|bB\\
    &A\rarr cA|d\\
    &B\rarr cB|d\\
\end{align*}$$

该文法构造的项目有18个$$\begin{align*}
    1:&S'\rarr\cdot E\\
    2:&S'\rarr E\cdot\\
    3:&E\rarr\cdot aA\\
    4:&E\rarr a\cdot A\\
    5:&E\rarr aA\cdot\\
    6:&A\rarr\cdot cA\\
    7:&A\rarr c\cdot A\\
    8:&A\rarr cA\cdot\\
    9:&A\rarr\cdot d\\
    10:&A\rarr d\cdot\\
    11:&E\rarr\cdot bB\\
    12:&E\rarr b\cdot B\\
    13:&E\rarr bB\cdot\\
    14:&B\rarr\cdot cB\\
    15:&B\rarr c\cdot B\\
    16:&B\rarr cB\cdot\\
    17:&B\rarr \cdot d\\
    18:&B\rarr d\cdot\\
\end{align*}$$

1. 规定项目1为NFA的唯一初态
2. 对于出自同一产生式的状态i和j,且状态j的圆点只落后状态i的一个位置,即状态i为$$X\rarr X_1\cdots X_{i-1}\cdot X_i\cdots X_n$$状态j为:$$X\rarr X_1\cdots X_{i}\cdot X_{i+1}\cdots X_n$$,从状态i画一条弧到状态j,弧标记为$X_i$.
3. 如果状态i为$X\rarr a\cdot A\beta$,$A$为非终结符,从状态i画$\epsilon$弧到所有的$A\rarr\cdot \gamma$状态
4. 按照NFA化为DFA的方法化为DFA,化简DFA,DFA中的项目记为I

得到NFA如下:

```mermaid
flowchart LR
    id1((1))-->|ε|id3((3))
    id1-->|E|id2(((2)))
    id1-->|ε|id11((11))
    id3-->|a|id4((4))
    id4-->|A|id5(((5)))
    id4-->|ε|id6((6))
    id4-->|ε|id9((9))
    id6-->|c|id7((7))
    id7-->|ε|id6
    id7-->|A|id8(((8)))
    id7-->|ε|id9
    id9-->|d|id10(((10)))
    id11-->|b|id12((12))
    id12-->|B|id13(((13)))
    id12-->|ε|id17((17))
    id17-->|d|id18(((18)))
    id12-->|ε|id14((14))
    id14-->|c|id15((15))
    id14-->|ε|id15
    id15-->|ε|id17
    id15-->|B|id16(((16)))
```

得到DFA如下:

```mermaid
flowchart LR
    id0["0:S'→.E\nE→.aA\nE→.bB"]
    id2["2:E→a\nA→.cA\nA→.d"]
    id1["1:S'→E."]
    id3["3:E→b.B\nB→.cB\nB→.d"]
    id4["4:A→c.A\nA→.cA\nA→.d"]
    id5["5:B→c.B\nB→.cB\nB→.d"]
    id6["6:E→aA."]
    id7["7:E→bB."]
    id8["8:A→cA."]
    id9["9:B→cB."]
    id10["10:A→d."]
    id11["11:B→d."]

    id0-->|a|id2
    id2-->|c|id4
    id4-->|c|id4
    id4-->|A|id8
    id4-->|d|id10
    id2-->|d|id10
    id2-->|A|id6
    id0-->|E|id1
    id0-->|b|id3
    id3-->|B|id7
    id3-->|d|id11
    id3-->|c|id5
    id5-->|d|id11
    id5-->|B|id9
    
```

得到DFA后按如下步骤构造LR分析表

1. 若项目$A\rarr\alpha\cdot a\beta$属于项目$I_k$,且从$I_k$到$I_j$有标记为$a$的弧即$GO(I_k,a)=I_j$把$ACTION[k,a]$放置将$(j,a)$进栈记为$s_j$
2. 若项目$A\rarr a\cdot$属于项目$I_k$,对任何终结符,把$ACTION[k,a]$放置用产生式$A\rarr a$规约,记为$r_j$,设产生式$A\rarr a$为文法的第$j$个产生式
3. 若项目$S'\rarr S\cdot$属于项目$I_k$,则把$ACTION[k,\#]$放置为接受记为$acc$
4. 若$GO(I_k,A)=I_j$,A为非终结符,则放$GOTO[k,A]$为$j$

具体操作:项目集对应状态(行),终结符和非终结符对应(列),如果是项目集1和2间的连线,如果是终结符,就在项目集1的行,对应的终结符的列写s2;
如果是连线是非终结符,就在该行对应的非终结符的列的位置标2,2代表项目集2
如果项目集点在最后面(只有进的线,没有出的线),在该行对应的所有终结符的列上填上项目集里的产生式(项目集里对应的在题目中给出的产生式)的编号

|状态|a|b|c|d|#|E|A|B|
|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|
|0|s2|s3||||1|||
|1|||||acc||||
|2|||s4|s10|||6||
|3|||s5|s11||||7|
|4|||s4|s10||8|||
|5||||s11||||9
|6|r1|r1|r1|r1|r1||||
|7|r2|r2|r2|r2|r2||||
|8|r3|r3|r3|r3|r3||||
|9|r5|r5|r5|r5|r5||||
|10|r4|r4|r4|r4|r4||||
|11|r6|r6|r6|r6|r6||||

##### SLR分析表的构造

在构造LR(0)分析表的基础上,当出现以下项目集时$$I=\left\{\begin{align*}
    X\rarr&a\cdot b\beta\\
    A\rarr&a\cdot\\
    B\rarr&a\cdot\\
\end{align*}\right\}$$在面对在面对任何输入符号$a$采取以下三种决策方法:

1. $a=b$,移进
2. $a\in FOLLOW(A)$,用产生式$A\rarr a$进行规约
3. $a\in FOLLOW(B)$,用产生式$B\rarr a$进行规约

一般来说,假定LR(0)中的一个项目集有$m$个移进项目:$$A_1\rarr \alpha\cdot a_1\beta_1,A_2\rarr \alpha\cdot a_2\beta_2,\cdots,A_m\rarr \alpha\cdot a_m\beta_m$$,$n$个规约项目:$$B_1\rarr\alpha\cdot,B_2\rarr\alpha\cdot,\cdots,B_n\rarr\alpha\cdot$$.
当集合$\{a_1,a_2,\cdots,a_m\},FOLLOW(B_1),FOLLOW(B_2),\cdots,FOLLOW(B_n)$两两不相交时,可采取类似上面的方法进行解决,具体如下

1. $a=a_i,(i=1,2,\dots,m)$时移进
2. $a\in FOLLOW(B_i),(i=1,2,\dots,n)$,用产生式$B_i\rarr a$进行规约
